{"version":3,"file":"hashids.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,UAAW,GAAIH,GACI,iBAAZC,QACdA,QAAiB,QAAID,IAErBD,EAAc,QAAIC,GACnB,CATD,CASGK,MAAM,I,mBCRT,IAAIC,EAAsB,CCA1BA,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,4BCE3E,MAYMI,EAAmBC,GACjB,iBAANA,IACLC,OAAOC,MAAMD,OAAOD,KAAOG,KAAKC,MAAMH,OAAOD,MAAQA,EAE5CK,EAAuBL,GACrB,iBAANA,GAAmBA,GAAK,GAAKC,OAAOK,cAAcN,GAEpD,SAASO,EACdC,EACAC,GAEA,GAAyB,IAArBA,EAAUC,OACZ,OAAOF,EAGT,IAAIG,EACJ,MAAMC,EAAc,IAAIJ,GAExB,IAAK,IAAIK,EAAID,EAAYF,OAAS,EAAGI,EAAI,EAAGC,EAAI,EAAGF,EAAI,EAAGA,IAAKC,IAAK,CAClEA,GAAKL,EAAUC,OAEfK,GAAKJ,EAAUF,EAAUK,GAAIE,YAAY,GACzC,MAAMC,GAAKN,EAAUG,EAAIC,GAAKF,EAGxBK,EAAIN,EAAYC,GAChBM,EAAIP,EAAYK,GACtBL,EAAYK,GAAKC,EACjBN,EAAYC,GAAKM,C,CAGnB,OAAOP,CACT,CAEO,MAuBMQ,EAAe,CAC1BC,EACAb,IAEAa,EAAWC,QAAmB,CAACC,EAAOC,KACpC,MAAMC,EAAQjB,EAAckB,QAAQF,GACpC,IAAe,IAAXC,EACF,MAAM,IAAIE,MACR,oBAAoBN,EAAWO,KAC7B,iFAC6EpB,EAAcoB,KAC3F,QAIN,GAAqB,iBAAVL,EACT,OAAOA,EAAQM,OAAOrB,EAAcE,QAAUmB,OAAOJ,GAEvD,MAAMK,EAAQP,EAAQf,EAAcE,OAASe,EAE7C,OADoBxB,OAAOK,cAAcwB,GAEhCA,GAGTC,EACE,8GAGKF,OAAON,GAASM,OAAOrB,EAAcE,QAAUmB,OAAOJ,GAAM,GAClE,GAECO,EAA0B,WA6BnBC,EAAwBC,GACnC,IAAIC,OACFD,EACGE,KAAKC,GAASC,EAAaD,KAG3BE,MAAK,CAACrB,EAAGC,IAAMA,EAAET,OAASQ,EAAER,SAC5BkB,KAAK,MAaNU,EAAgBE,GACpBA,EAAKC,QAAQ,2BAA4B,QAErCV,EAA4B,CAChCW,EAAuB,iDAEvB,GAAsB,mBAAXb,OACT,MAAM,IAAIc,UAAUD,E,ECvIT,MAAME,EASnBC,YACEC,EAAO,GACCC,EAAY,EACpBC,EAAW,iEACXC,EAAO,kBAEP,GAJQ,KAAAF,UAAAA,EAIiB,iBAAdA,EACT,MAAM,IAAIJ,UACR,+DAA+DI,MAGnE,GAAoB,iBAATD,EACT,MAAM,IAAIH,UACR,0DAA0DG,MAG9D,GAAwB,iBAAbE,EACT,MAAM,IAAIL,UACR,4DAA4DK,MAIhE,MAAMvC,EAAYyC,MAAMC,KAAKL,GACvBtC,EAAgB0C,MAAMC,KAAKH,GAC3BI,EAAYF,MAAMC,KAAKF,GAE7BI,KAAKP,KAAOrC,EAEZ,MAAM6C,ED1DkD,IACvD,IAAIC,ICyD6B/C,ID1DZ,IAMxBgD,ECsDE,GAAIF,EAAe5C,OA9CK,GA+CtB,MAAM,IAAIiB,MACR,2EAA+F2B,EAAe1B,KAC5G,OAMNyB,KAAKL,UD/DPQ,EC+D+CJ,EAAhBE,ED9DZG,QAAQpB,IAAUmB,EAAeE,SAASrB,MCgE3D,MAAMsB,GD9DiCC,EC8DGN,EAAXF,ED7D3BK,QAAQpB,GAASuB,EAAUF,SAASrB,MADnB,IAAkBuB,ECiEvC,IAAIC,EACAC,EAHJT,KAAKJ,KAAO1C,EAAQoD,EAAclD,IAMX,IAArB4C,KAAKJ,KAAKvC,QACV2C,KAAKL,SAAStC,OAAS2C,KAAKJ,KAAKvC,OAhEjB,OAkEhBmD,EAAa1D,KAAK4D,KAAKV,KAAKL,SAAStC,OAlErB,KAoEZmD,EAAaR,KAAKJ,KAAKvC,SACzBoD,EAAOD,EAAaR,KAAKJ,KAAKvC,OAC9B2C,KAAKJ,KAAKe,QAAQX,KAAKL,SAASiB,MAAM,EAAGH,IACzCT,KAAKL,SAAWK,KAAKL,SAASiB,MAAMH,KAIxCT,KAAKL,SAAWzC,EAAQ8C,KAAKL,SAAUvC,GACvC,MAAMyD,EAAa/D,KAAK4D,KAAKV,KAAKL,SAAStC,OA3E7B,IA6EV2C,KAAKL,SAAStC,OAAS,GACzB2C,KAAKc,OAASd,KAAKJ,KAAKgB,MAAM,EAAGC,GACjCb,KAAKJ,KAAOI,KAAKJ,KAAKgB,MAAMC,KAE5Bb,KAAKc,OAASd,KAAKL,SAASiB,MAAM,EAAGC,GACrCb,KAAKL,SAAWK,KAAKL,SAASiB,MAAMC,IAGtCb,KAAKe,aAAenC,EAAqBoB,KAAKc,QAC9Cd,KAAKgB,WAAapC,EAAqBoB,KAAKJ,MAC5CI,KAAKiB,mBDoCgC,CAACpC,GACxC,IAAIC,OACF,KAAKD,EACFE,KAAKC,GAASC,EAAaD,KAG3BE,MAAK,CAACrB,EAAGC,IAAMA,EAAET,OAASQ,EAAER,SAC5BkB,KAAK,UC3CkB2C,CAA0B,IAC/ClB,KAAKL,YACLK,KAAKc,UACLd,KAAKJ,MAEZ,CAKAuB,OACEC,KACGC,GAIH,IAAIC,EAAezB,MAAM0B,QAAQH,GAC7BA,EACA,IAAc,MAATA,EAAgB,CAACA,GAAS,MAAQC,GAE3C,OAAuB,IAAnBC,EAAQjE,OANA,IAUPiE,EAAQE,MAAM9E,KACjB4E,EAAUA,EAAQvC,KAAKpC,GACR,iBAANA,GAA+B,iBAANA,EAC5BA,ED5BkB,CAAC8E,IAC7B,IAAK9C,EAAwB+C,KAAKD,GAChC,OAAO7E,OAAO+E,IAGhB,MAAMC,EAAQhF,OAAOiF,SAASJ,EAAK,IAEnC,OAAI7E,OAAOK,cAAc2E,GAChBA,GAGTlD,EACE,6IAGKF,OAAOiD,GAAI,ECcRK,CAAeC,OAAOpF,OAIxB2E,EAAyBE,MAAMxE,GAI9BgD,KAAKgC,QAAQV,GAAqB/C,KAAK,IAtBlC,GAuBd,CAEA0D,OAAOC,GACL,OAAKA,GAAoB,iBAAPA,GAAiC,IAAdA,EAAG7E,OACjC2C,KAAKmC,QAAQD,GADyC,EAE/D,CAiBAE,UAAUC,GACR,IAAIC,EAAMD,EACV,cAAeC,GACb,IAAK,SACHA,EAAMA,EAAIC,SArJE,IAsJZ,MACF,IAAK,SACH,IAAK,gBAAgBb,KAAKY,GAAM,MAAO,GACvC,MACF,QACE,MAAM,IAAIhE,MACR,8EAA8EgE,MAIpF,MAAMhB,GDxDRG,ECwDwCa,EA/Jf,GDyGzBvD,ECsDkEyD,GAC9D5F,OAAOiF,SAAS,IAAIW,IAAQ,IDrDhC3C,MAAMC,KAAe,CAAEzC,OAAQP,KAAK4D,KAAKe,EAAIpE,OC3GpB,MD2GqC,CAACoF,EAAGrE,IAChEW,EAAI0C,EAAIb,MC5Ge,GD4GTxC,EC5GS,ID4GKA,EAAQ,QANH,IACnCqD,EAEA1C,ECyDE,OAAOiB,KAAKmB,OAAOG,EACrB,CAEAoB,UAAUR,GACR,OAAOlC,KAAKiC,OAAOC,GAChBnD,KAAK4D,GAAWA,EAAOJ,SAxKV,IAwKgC3B,MAAM,KACnDrC,KAAK,GACV,CAEAqE,UAAUV,GACR,OAAOlC,KAAKiB,mBAAmBS,KAAKQ,EACtC,CAEQF,QAAQV,GACd,IAAI,SAAE3B,GAAaK,KAEnB,MAAM6C,EAAevB,EAAQrD,QAC3B,CAAC6E,EAAMH,EAAQnF,IACbsF,GACmB,iBAAXH,EACJ/F,OAAO+F,EAASnE,OAAOhB,EApLf,MAqLRmF,GAAUnF,EArLF,OAsLd,GAGF,IAAIuF,EAAgB,CAACpD,EAASkD,EAAelD,EAAStC,SACtD,MAAM2F,EAAU,IAAID,IAEd,KAAEnD,GAASI,MACX,OAAEc,GAAWd,KAoBnB,GAlBAsB,EAAQ2B,SAAQ,CAACN,EAAQnF,KACvB,MAAM0F,EAASF,EAAQG,OAAOnD,KAAKP,KAAME,GAEzCA,EAAWzC,EAAQyC,EAAUuD,GAC7B,MAAMJ,EDzKc,EACxBM,EACAjG,KAEA,MAAM+E,EAAe,GACrB,IAAIzD,EAAQ2E,EAEZ,GAAqB,iBAAV3E,EAAoB,CAC7B,MAAM4E,EAAiB7E,OAAOrB,EAAcE,QAC5C,GACE6E,EAAGoB,QAAQnG,EAAcP,OAAO6B,EAAQ4E,KACxC5E,GAAS4E,QACF5E,EAAQD,OAAO,G,MAExB,GACE0D,EAAGoB,QAAQnG,EAAcsB,EAAQtB,EAAcE,SAC/CoB,EAAQ3B,KAAKC,MAAM0B,EAAQtB,EAAcE,cAClCoB,EAAQ,GAGnB,OAAOyD,CAAE,ECqJQqB,CAAWZ,EAAQhD,GAIhC,GAFAoD,EAAIpC,QAAQmC,GAERtF,EAAI,EAAI8D,EAAQjE,OAAQ,CAC1B,MAAMmG,EAAWV,EAAK,GAAInF,YAAY,GAAMH,EACtCiG,EACc,iBAAXd,EACH/F,OAAO+F,EAASnE,OAAOgF,IACvBb,EAASa,EACfT,EAAIpC,KAAKf,EAAK6D,EAAc7D,EAAKvC,Q,KAIjC0F,EAAI1F,OAAS2C,KAAKN,UAAW,CAC/B,MAAMgE,GACHb,EAAeE,EAAI,GAAIpF,YAAY,IAAOmD,EAAOzD,OAGpD,GAFA0F,EAAIO,QAAQxC,EAAO4C,IAEfX,EAAI1F,OAAS2C,KAAKN,UAAW,CAC/B,MAAMiE,GACHd,EAAeE,EAAI,GAAIpF,YAAY,IAAOmD,EAAOzD,OACpD0F,EAAIpC,KAAKG,EAAO6C,G,EAIpB,MAAMC,EAAa9G,KAAKC,MAAM4C,EAAStC,OAAS,GAChD,KAAO0F,EAAI1F,OAAS2C,KAAKN,WAAW,CAClCC,EAAWzC,EAAQyC,EAAUA,GAC7BoD,EAAIO,WAAW3D,EAASiB,MAAMgD,IAC9Bb,EAAIpC,QAAQhB,EAASiB,MAAM,EAAGgD,IAE9B,MAAMC,EAASd,EAAI1F,OAAS2C,KAAKN,UACjC,GAAImE,EAAS,EAAG,CACd,MAAMC,EAAeD,EAAS,EAC9Bd,EAAMA,EAAInC,MAAMkD,EAAcA,EAAe9D,KAAKN,U,EAItD,OAAOqD,CACT,CAEQZ,QAAQD,GACd,IAAKlC,KAAK4C,UAAUV,GAClB,MAAM,IAAI5D,MACR,oBAAoB4D,+EAAgFlC,KAAKc,OAAOvC,KAC9G,MACEyB,KAAKJ,KAAKrB,KAAK,MAAMyB,KAAKL,SAASpB,KAAK,QAGhD,MAAMwF,EAAgB7B,EAAG8B,MAAMhE,KAAKe,cAI9BkD,EAAcF,EAFO,IAAzBA,EAAc1G,QAAyC,IAAzB0G,EAAc1G,OAAe,EAAI,GAGjE,GAA2B,IAAvB4G,EAAY5G,OAAc,MAAO,GAErC,MAAM6G,EAAcD,EAAYE,OAAOC,YAAYC,OAAO5F,MACpD6F,EAAUL,EAAYrD,MAAMsD,EAAY7G,QAAQ2G,MAAMhE,KAAKgB,YAEjE,IAAIuD,EAAyBvE,KAAKL,SAClC,MAAM6E,EAAuB,GAE7B,IAAK,MAAMC,KAASH,EAAS,CAC3B,MACMI,EAAexH,EACnBqH,EAFa,CAACL,KAAgBlE,KAAKP,QAAS8E,GAGrC3D,MAAM,EAAG2D,EAAalH,SAE/BmH,EAAO7D,KAAK5C,EAAa8B,MAAMC,KAAK2E,GAAQC,IAC5CH,EAAeG,C,CAIjB,OAAI1E,KAAKgC,QAAQwC,GAAQjG,KAAK,MAAQ2D,EAAW,GAC1CsC,CACT,E","sources":["webpack://Hashids/webpack/universalModuleDefinition","webpack://Hashids/webpack/bootstrap","webpack://Hashids/webpack/runtime/define property getters","webpack://Hashids/webpack/runtime/hasOwnProperty shorthand","webpack://Hashids/./src/util.ts","webpack://Hashids/./src/hashids.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Hashids\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Hashids\"] = factory();\n\telse\n\t\troot[\"Hashids\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export type NumberLike = bigint | number\n\nexport const keepUnique = <T>(content: Iterable<T>): T[] => [\n  ...new Set(content),\n]\n\nexport const withoutChars = (\n  chars: string[],\n  charsToExclude: string[],\n): string[] => chars.filter((char) => !charsToExclude.includes(char))\n\nexport const onlyChars = (chars: string[], keepChars: string[]): string[] =>\n  chars.filter((char) => keepChars.includes(char))\n\nexport const isIntegerNumber = (n: NumberLike | string) =>\n  typeof n === 'bigint' ||\n  (!Number.isNaN(Number(n)) && Math.floor(Number(n)) === n)\n\nexport const isPositiveAndFinite = (n: NumberLike) =>\n  typeof n === 'bigint' || (n >= 0 && Number.isSafeInteger(n))\n\nexport function shuffle(\n  alphabetChars: string[],\n  saltChars: string[],\n): string[] {\n  if (saltChars.length === 0) {\n    return alphabetChars\n  }\n\n  let integer: number\n  const transformed = [...alphabetChars]\n\n  for (let i = transformed.length - 1, v = 0, p = 0; i > 0; i--, v++) {\n    v %= saltChars.length\n    // eslint-disable-next-line no-multi-assign\n    p += integer = saltChars[v]!.codePointAt(0)!\n    const j = (integer + v + p) % i\n\n    // swap characters at positions i and j\n    const a = transformed[i]!\n    const b = transformed[j]!\n    transformed[j] = a\n    transformed[i] = b\n  }\n\n  return transformed\n}\n\nexport const toAlphabet = (\n  input: NumberLike,\n  alphabetChars: string[],\n): string[] => {\n  const id: string[] = []\n  let value = input\n\n  if (typeof value === 'bigint') {\n    const alphabetLength = BigInt(alphabetChars.length)\n    do {\n      id.unshift(alphabetChars[Number(value % alphabetLength)]!)\n      value /= alphabetLength\n    } while (value > BigInt(0))\n  } else {\n    do {\n      id.unshift(alphabetChars[value % alphabetChars.length]!)\n      value = Math.floor(value / alphabetChars.length)\n    } while (value > 0)\n  }\n\n  return id\n}\n\nexport const fromAlphabet = (\n  inputChars: string[],\n  alphabetChars: string[],\n): NumberLike =>\n  inputChars.reduce<NumberLike>((carry, item) => {\n    const index = alphabetChars.indexOf(item)\n    if (index === -1) {\n      throw new Error(\n        `The provided ID (${inputChars.join(\n          '',\n        )}) is invalid, as it contains characters that do not exist in the alphabet (${alphabetChars.join(\n          '',\n        )})`,\n      )\n    }\n    if (typeof carry === 'bigint') {\n      return carry * BigInt(alphabetChars.length) + BigInt(index)\n    }\n    const value = carry * alphabetChars.length + index\n    const isSafeValue = Number.isSafeInteger(value)\n    if (isSafeValue) {\n      return value\n    }\n\n    throwIfBigIntNotAvailable(\n      `Unable to decode the provided string, due to lack of support for BigInt numbers in the current environment`,\n    )\n\n    return BigInt(carry) * BigInt(alphabetChars.length) + BigInt(index)\n  }, 0)\n\nconst safeToParseNumberRegExp = /^\\+?\\d+$/\n\nexport const safeParseInt10 = (str: string) => {\n  if (!safeToParseNumberRegExp.test(str)) {\n    return Number.NaN\n  }\n\n  const int10 = Number.parseInt(str, 10)\n\n  if (Number.isSafeInteger(int10)) {\n    return int10\n  }\n\n  throwIfBigIntNotAvailable(\n    'Unable to encode the provided BigInt string without loss of information due to lack of support for BigInt type in the current environment',\n  )\n\n  return BigInt(str)\n}\n\nexport const splitAtIntervalAndMap = <T>(\n  str: string,\n  nth: number,\n  map: (n: string) => T,\n): T[] =>\n  Array.from<never, T>({ length: Math.ceil(str.length / nth) }, (_, index) =>\n    map(str.slice(index * nth, (index + 1) * nth)),\n  )\n\nexport const makeAnyOfCharsRegExp = (chars: string[]) =>\n  new RegExp(\n    chars\n      .map((char) => escapeRegExp(char))\n      // we need to sort these from longest to shortest,\n      // as they may contain multibyte unicode characters (these should come first)\n      .sort((a, b) => b.length - a.length)\n      .join('|'),\n  )\n\nexport const makeAtLeastSomeCharRegExp = (chars: string[]) =>\n  new RegExp(\n    `^[${chars\n      .map((char) => escapeRegExp(char))\n      // we need to sort these from longest to shortest,\n      // as they may contain multibyte unicode characters (these should come first)\n      .sort((a, b) => b.length - a.length)\n      .join('')}]+$`,\n  )\n\nconst escapeRegExp = (text: string) =>\n  text.replace(/[\\s#$()*+,.?[\\\\\\]^{|}-]/g, '\\\\$&')\n\nconst throwIfBigIntNotAvailable = (\n  errorMessage: string = 'BigInt is not available in this environment',\n) => {\n  if (typeof BigInt !== 'function') {\n    throw new TypeError(errorMessage)\n  }\n}\n","import type { NumberLike } from './util'\nimport {\n  fromAlphabet,\n  isIntegerNumber,\n  isPositiveAndFinite,\n  keepUnique,\n  makeAnyOfCharsRegExp,\n  makeAtLeastSomeCharRegExp,\n  onlyChars,\n  safeParseInt10,\n  shuffle,\n  splitAtIntervalAndMap,\n  toAlphabet,\n  withoutChars,\n} from './util'\n\nconst MIN_ALPHABET_LENGTH = 16\nconst SEPARATOR_DIV = 3.5\nconst GUARD_DIV = 12\nconst HEXADECIMAL = 16\nconst SPLIT_AT_EVERY_NTH = 12\n\nconst MODULO_PART = 100\nexport default class Hashids {\n  private alphabet: string[]\n  private seps: string[]\n  private guards: string[]\n  private salt: string[]\n  private guardsRegExp: RegExp\n  private sepsRegExp: RegExp\n  private allowedCharsRegExp: RegExp\n\n  constructor(\n    salt = '',\n    private minLength = 0,\n    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890',\n    seps = 'cfhistuCFHISTU',\n  ) {\n    if (typeof minLength !== 'number') {\n      throw new TypeError(\n        `Hashids: Provided 'minLength' has to be a number (is ${typeof minLength})`,\n      )\n    }\n    if (typeof salt !== 'string') {\n      throw new TypeError(\n        `Hashids: Provided 'salt' has to be a string (is ${typeof salt})`,\n      )\n    }\n    if (typeof alphabet !== 'string') {\n      throw new TypeError(\n        `Hashids: Provided alphabet has to be a string (is ${typeof alphabet})`,\n      )\n    }\n\n    const saltChars = Array.from(salt)\n    const alphabetChars = Array.from(alphabet)\n    const sepsChars = Array.from(seps)\n\n    this.salt = saltChars\n\n    const uniqueAlphabet = keepUnique(alphabetChars)\n\n    if (uniqueAlphabet.length < MIN_ALPHABET_LENGTH) {\n      throw new Error(\n        `Hashids: alphabet must contain at least ${MIN_ALPHABET_LENGTH} unique characters, provided: ${uniqueAlphabet.join(\n          '',\n        )}`,\n      )\n    }\n\n    /** `alphabet` should not contains `seps` */\n    this.alphabet = withoutChars(uniqueAlphabet, sepsChars)\n    /** `seps` should contain only characters present in `alphabet` */\n    const filteredSeps = onlyChars(sepsChars, uniqueAlphabet)\n    this.seps = shuffle(filteredSeps, saltChars)\n\n    let sepsLength\n    let diff\n\n    if (\n      this.seps.length === 0 ||\n      this.alphabet.length / this.seps.length > SEPARATOR_DIV\n    ) {\n      sepsLength = Math.ceil(this.alphabet.length / SEPARATOR_DIV)\n\n      if (sepsLength > this.seps.length) {\n        diff = sepsLength - this.seps.length\n        this.seps.push(...this.alphabet.slice(0, diff))\n        this.alphabet = this.alphabet.slice(diff)\n      }\n    }\n\n    this.alphabet = shuffle(this.alphabet, saltChars)\n    const guardCount = Math.ceil(this.alphabet.length / GUARD_DIV)\n\n    if (this.alphabet.length < 3) {\n      this.guards = this.seps.slice(0, guardCount)\n      this.seps = this.seps.slice(guardCount)\n    } else {\n      this.guards = this.alphabet.slice(0, guardCount)\n      this.alphabet = this.alphabet.slice(guardCount)\n    }\n\n    this.guardsRegExp = makeAnyOfCharsRegExp(this.guards)\n    this.sepsRegExp = makeAnyOfCharsRegExp(this.seps)\n    this.allowedCharsRegExp = makeAtLeastSomeCharRegExp([\n      ...this.alphabet,\n      ...this.guards,\n      ...this.seps,\n    ])\n  }\n\n  encode(numbers: NumberLike[] | string[] | string): string\n  encode(...numbers: NumberLike[]): string\n  encode(...numbers: string[]): string\n  encode<T extends NumberLike | string>(\n    first: T | T[],\n    ...inputNumbers: T[]\n  ): string {\n    const ret = ''\n\n    let numbers: T[] = Array.isArray(first)\n      ? first\n      : [...(first != null ? [first] : []), ...inputNumbers]\n\n    if (numbers.length === 0) {\n      return ret\n    }\n\n    if (!numbers.every(isIntegerNumber)) {\n      numbers = numbers.map((n) =>\n        typeof n === 'bigint' || typeof n === 'number'\n          ? n\n          : safeParseInt10(String(n)),\n      ) as T[]\n    }\n\n    if (!(numbers as NumberLike[]).every(isPositiveAndFinite)) {\n      return ret\n    }\n\n    return this._encode(numbers as number[]).join('')\n  }\n\n  decode(id: string): NumberLike[] {\n    if (!id || typeof id !== 'string' || id.length === 0) return []\n    return this._decode(id)\n  }\n\n  /**\n   * @description Splits a hex string into groups of 12-digit hexadecimal numbers,\n   * then prefixes each with '1' and encodes the resulting array of numbers\n   *\n   * Encoding '00000000000f00000000000f000f' would be the equivalent of:\n   * Hashids.encode([0x100000000000f, 0x100000000000f, 0x1000f])\n   *\n   * This means that if your environment supports BigInts,\n   * you will get different (shorter) results if you provide\n   * a BigInt representation of your hex and use `encode` directly, e.g.:\n   * Hashids.encode(BigInt(`0x${hex}`))\n   *\n   * To decode such a representation back to a hex string, use the following snippet:\n   * Hashids.decode(id)[0].toString(16)\n   */\n  encodeHex(inputHex: bigint | string): string {\n    let hex = inputHex\n    switch (typeof hex) {\n      case 'bigint':\n        hex = hex.toString(HEXADECIMAL)\n        break\n      case 'string':\n        if (!/^[\\dA-Fa-f]+$/.test(hex)) return ''\n        break\n      default:\n        throw new Error(\n          `Hashids: The provided value is neither a string, nor a BigInt (got: ${typeof hex})`,\n        )\n    }\n\n    const numbers = splitAtIntervalAndMap(hex, SPLIT_AT_EVERY_NTH, (part) =>\n      Number.parseInt(`1${part}`, 16),\n    )\n    return this.encode(numbers)\n  }\n\n  decodeHex(id: string): string {\n    return this.decode(id)\n      .map((number) => number.toString(HEXADECIMAL).slice(1))\n      .join('')\n  }\n\n  isValidId(id: string): boolean {\n    return this.allowedCharsRegExp.test(id)\n  }\n\n  private _encode(numbers: NumberLike[]): string[] {\n    let { alphabet } = this\n\n    const numbersIdInt = numbers.reduce<number>(\n      (last, number, i) =>\n        last +\n        (typeof number === 'bigint'\n          ? Number(number % BigInt(i + MODULO_PART))\n          : number % (i + MODULO_PART)),\n      0,\n    )\n\n    let ret: string[] = [alphabet[numbersIdInt % alphabet.length]!]\n    const lottery = [...ret]\n\n    const { seps } = this\n    const { guards } = this\n\n    numbers.forEach((number, i) => {\n      const buffer = lottery.concat(this.salt, alphabet)\n\n      alphabet = shuffle(alphabet, buffer)\n      const last = toAlphabet(number, alphabet)\n\n      ret.push(...last)\n\n      if (i + 1 < numbers.length) {\n        const charCode = last[0]!.codePointAt(0)! + i\n        const extraNumber =\n          typeof number === 'bigint'\n            ? Number(number % BigInt(charCode))\n            : number % charCode\n        ret.push(seps[extraNumber % seps.length]!)\n      }\n    })\n\n    if (ret.length < this.minLength) {\n      const prefixGuardIndex =\n        (numbersIdInt + ret[0]!.codePointAt(0)!) % guards.length\n      ret.unshift(guards[prefixGuardIndex]!)\n\n      if (ret.length < this.minLength) {\n        const suffixGuardIndex =\n          (numbersIdInt + ret[2]!.codePointAt(0)!) % guards.length\n        ret.push(guards[suffixGuardIndex]!)\n      }\n    }\n\n    const halfLength = Math.floor(alphabet.length / 2)\n    while (ret.length < this.minLength) {\n      alphabet = shuffle(alphabet, alphabet)\n      ret.unshift(...alphabet.slice(halfLength))\n      ret.push(...alphabet.slice(0, halfLength))\n\n      const excess = ret.length - this.minLength\n      if (excess > 0) {\n        const halfOfExcess = excess / 2\n        ret = ret.slice(halfOfExcess, halfOfExcess + this.minLength)\n      }\n    }\n\n    return ret\n  }\n\n  private _decode(id: string): NumberLike[] {\n    if (!this.isValidId(id)) {\n      throw new Error(\n        `The provided ID (${id}) is invalid, as it contains characters that do not exist in the alphabet (${this.guards.join(\n          '',\n        )}${this.seps.join('')}${this.alphabet.join('')})`,\n      )\n    }\n    const idGuardsArray = id.split(this.guardsRegExp)\n    const splitIndex =\n      idGuardsArray.length === 3 || idGuardsArray.length === 2 ? 1 : 0\n\n    const idBreakdown = idGuardsArray[splitIndex]!\n    if (idBreakdown.length === 0) return []\n\n    const lotteryChar = idBreakdown[Symbol.iterator]().next().value as string\n    const idArray = idBreakdown.slice(lotteryChar.length).split(this.sepsRegExp)\n\n    let lastAlphabet: string[] = this.alphabet\n    const result: NumberLike[] = []\n\n    for (const subId of idArray) {\n      const buffer = [lotteryChar, ...this.salt, ...lastAlphabet]\n      const nextAlphabet = shuffle(\n        lastAlphabet,\n        buffer.slice(0, lastAlphabet.length),\n      )\n      result.push(fromAlphabet(Array.from(subId), nextAlphabet))\n      lastAlphabet = nextAlphabet\n    }\n\n    // if the result is different from what we'd expect, we return an empty result (malformed input):\n    if (this._encode(result).join('') !== id) return []\n    return result\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","isIntegerNumber","n","Number","isNaN","Math","floor","isPositiveAndFinite","isSafeInteger","shuffle","alphabetChars","saltChars","length","integer","transformed","i","v","p","codePointAt","j","a","b","fromAlphabet","inputChars","reduce","carry","item","index","indexOf","Error","join","BigInt","value","throwIfBigIntNotAvailable","safeToParseNumberRegExp","makeAnyOfCharsRegExp","chars","RegExp","map","char","escapeRegExp","sort","text","replace","errorMessage","TypeError","Hashids","constructor","salt","minLength","alphabet","seps","Array","from","sepsChars","this","uniqueAlphabet","Set","charsToExclude","filter","includes","filteredSeps","keepChars","sepsLength","diff","ceil","push","slice","guardCount","guards","guardsRegExp","sepsRegExp","allowedCharsRegExp","makeAtLeastSomeCharRegExp","encode","first","inputNumbers","numbers","isArray","every","str","test","NaN","int10","parseInt","safeParseInt10","String","_encode","decode","id","_decode","encodeHex","inputHex","hex","toString","part","_","decodeHex","number","isValidId","numbersIdInt","last","ret","lottery","forEach","buffer","concat","input","alphabetLength","unshift","toAlphabet","charCode","extraNumber","prefixGuardIndex","suffixGuardIndex","halfLength","excess","halfOfExcess","idGuardsArray","split","idBreakdown","lotteryChar","Symbol","iterator","next","idArray","lastAlphabet","result","subId","nextAlphabet"],"sourceRoot":""}